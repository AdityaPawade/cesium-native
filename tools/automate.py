#!/usr/bin/env python3
import argparse
import subprocess
import os
from unittest import skip
import yaml
import jinja2
from enum import Enum

env = jinja2.Environment(
    loader=jinja2.PackageLoader("automate"),
    autoescape=jinja2.select_autoescape(),
    trim_blocks=True,
    lstrip_blocks=True
)

def main():
  argParser = argparse.ArgumentParser(description='Automate cesium-native tasks')

  subparsers = argParser.add_subparsers(dest='task', help='Automation command to invoke')
  subparsers.required = True

  listDependenciesParser = subparsers.add_parser('list-dependencies', help='List the cesium-native libraries in dependency order, with libraries depended-upon listed before those that depend on them')
  listDependenciesParser.set_defaults(func=lambda x: executeInDependencyOrder(findCesiumLibraries(), print))

  editablesParser = subparsers.add_parser('editable', help='Change the Conan editable state of the cesium-native libraries')
  editablesParser.add_argument('state', choices=('on', 'off'), help='On to enable editable mode, off to disable it.')
  editablesParser.set_defaults(func=editable)

  exportRecipesParser = subparsers.add_parser('conan-export-recipes', help='Export the recipes in the "recipes" subdirectory to the Conan cache')
  exportRecipesParser.set_defaults(func=exportRecipes)

  generateLibraryRecipesParser = subparsers.add_parser('generate-library-recipes', help='Generate conanfile.py files for each Cesium library, and one in the root directory that depends on all the others.')
  generateLibraryRecipesParser.add_argument('--editable', action='store_true', help='Generate recipes for use with Cesium packages in Conan\'s "editable" mode. These recipes will not include dependencies _between_ Cesium libraries, because these are handled by CMake in the development workflow.')
  generateLibraryRecipesParser.add_argument('--build-folder', dest='buildFolder', help='The CMake/Conan build folder path to use in editable mode. If this is a relative path, it is relative to the cesium-native root directory. This option is ignored if --editable is not specified. Defaults to "build".', default='build')
  generateLibraryRecipesParser.set_defaults(func=generateLibraryRecipes)

  exportLibrariesParser = subparsers.add_parser('conan-export-libraries', help='Add every Cesium library to the Conan cache by running "conan export" on it')
  exportLibrariesParser.set_defaults(func=exportLibraries)

  args = argParser.parse_args()
  args.func(args)

def generateLibraryRecipes(args):
  if args.editable:
    templateFile = "editable-conanfile.py"
    skipNativeDependencies = True
  else:
    templateFile = "create-conanfile.py"
    skipNativeDependencies = False

  template = env.get_template(templateFile)

  libraries = findCesiumLibraries()

  with open('cesium-native.yml', 'r') as f:
    nativeYml = yaml.safe_load(f)

  # Write a recipe for every library.
  for library in libraries:
    with open(library + '/library.yml', 'r') as f:
      libraryYml = yaml.safe_load(f)

      path = library
      os.makedirs(path, exist_ok=True)
      with open(path + '/conanfile.py', 'w') as f:
        f.write('# Do not edit this file! It is created by running "tools/automate.py generate-library-recipes"\n\n')
        f.write(template.render(
          name=library,
          conanName=library.lower(),
          native=nativeYml,
          library=libraryYml,
          dependencies=resolveDependencies(libraries, nativeYml, libraryYml['dependencies'], skipNativeDependencies),
          testDependencies=resolveDependencies(libraries, nativeYml, libraryYml['testDependencies'], skipNativeDependencies),
          buildFolder=args.buildFolder
        ))

  # Write a top-level recipe
  rootTemplate = env.get_template('root-conanfile.py')
  with open('conanfile.py', 'w') as f:
    f.write('# Do not edit this file! It is created by running "tools/automate.py generate-library-recipes"\n\n')
    f.write(rootTemplate.render(
      native=nativeYml,
      skipNativeDependencies=skipNativeDependencies,
      dependencies=resolveDependencies(libraries, nativeYml, (name.lower() for name in libraries), False),
      testDependencies=[],
      buildFolder=args.buildFolder
    ))

def editable(args):
  with open('cesium-native.yml', 'r') as f:
    nativeYml = yaml.safe_load(f)

  def makeEditable(library):
    run('conan editable add %s %s/%s@%s/%s' % (library, library.lower(), nativeYml['version'], nativeYml['user'], nativeYml['channel']))

  def makeNonEditable(library):
    run('conan editable remove %s/%s@%s/%s' % (library.lower(), nativeYml['version'], nativeYml['user'], nativeYml['channel']))

  if args.state == 'on':
    template = 'editable-conanfile.py'
    skipNativeDependencies = True
    command = makeEditable
  else:
    template = 'create-conanfile.py'
    skipNativeDependencies = False
    command = makeNonEditable

  libraries = findCesiumLibraries()
  executeInDependencyOrder(libraries, command)

def exportRecipes(args):
  with open('cesium-native.yml', 'r') as f:
    nativeYml = yaml.safe_load(f)

  for recipe in nativeYml['extraRecipes']:
      run('conan export recipes/%s' % (recipe))

def exportLibraries(args):
  libraries = findCesiumLibraries()
  executeInDependencyOrder(libraries, lambda library: run('conan export %s' % (library)))

def findCesiumLibraries():
  # TODO: Get this from the filesystem, Cesium*
  return [
    'Cesium3DTiles',
    'Cesium3DTilesReader',
    'Cesium3DTilesSelection',
    'Cesium3DTilesWriter',
    'CesiumAsync',
    'CesiumGeometry',
    'CesiumGeospatial',
    'CesiumGltf',
    'CesiumGltfReader',
    'CesiumGltfWriter',
    'CesiumIonClient',
    'CesiumJsonReader',
    'CesiumJsonWriter',
    'CesiumUtility',
  ]

def resolveDependencies(nativeLibraries, nativeYml, dependencies, skipNativeDependencies):
  def resolveDependency(library):
    if library in (name.lower() for name in nativeLibraries):
      if skipNativeDependencies:
        return ''
      elif nativeYml['user'] or nativeYml['channel']:
        return '%s/%s@%s/%s' % (library, nativeYml['version'], nativeYml['user'], nativeYml['channel'])
      else:
        return '%s/%s' % (library, nativeYml['version'])
    else:
      versions = nativeYml['dependencyVersions']
      if library in versions:
        return '%s/%s' % (library, versions[library])
      else:
        return '%s/specify.version.in.cesium-native.yml' % (library)

  return filter(lambda s: len(s) > 0, map(resolveDependency, dependencies))

def executeInDependencyOrder(nativeLibraries, func):
  class State(Enum):
    NOT_VISITED = 0
    VISITED_DOWN = 1
    VISITED_UP = 2

  states = {}

  # Initially all libraries are not visited
  for library in nativeLibraries:
    states[library.lower()] = State.NOT_VISITED

  def recurse(library):
    currentState = states[library]
    if currentState == State.VISITED_DOWN:
      print('Detected a cycle in the dependency graph while visiting %s!' % (library))
      return

    if currentState == State.VISITED_UP:
      # Already visited
      return

    states[library] = State.VISITED_DOWN

    with open(library + '/library.yml', 'r') as f:
      libraryYml = yaml.safe_load(f)

    dependencies = [*libraryYml['dependencies'], *libraryYml['testDependencies']]
    for dependency in dependencies:
      if dependency.startswith('cesium'):
        recurse(dependency)

    states[library] = State.VISITED_UP

    func(library)

  for library in nativeLibraries:
    recurse(library.lower())

def run(command):
  result = subprocess.run(command, shell=True)
  if result.returncode != 0:
    exit(result.returncode)

if __name__ == "__main__":
  main()
