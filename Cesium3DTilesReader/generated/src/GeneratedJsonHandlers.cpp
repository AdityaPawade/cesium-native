// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "Extension3dTilesContentGltfJsonHandler.h"

#include <Cesium3DTiles/Extension3dTilesContentGltf.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

Extension3dTilesContentGltfJsonHandler::Extension3dTilesContentGltfJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _extensionsUsed(),
      _extensionsRequired() {}

void Extension3dTilesContentGltfJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Extension3dTilesContentGltf* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
Extension3dTilesContentGltfJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtension3dTilesContentGltf(
      Cesium3DTiles::Extension3dTilesContentGltf::TypeName,
      str,
      *this->_pObject);
}

void Extension3dTilesContentGltfJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumUtility::ExtensibleObject& o,
    const std::string_view& extensionName) {
  std::any& value =
      o.extensions
          .emplace(extensionName, Cesium3DTiles::Extension3dTilesContentGltf())
          .first->second;
  this->reset(
      pParentHandler,
      &std::any_cast<Cesium3DTiles::Extension3dTilesContentGltf&>(value));
}

CesiumJsonReader::IJsonHandler* Extension3dTilesContentGltfJsonHandler::
    readObjectKeyExtension3dTilesContentGltf(
        const std::string& objectType,
        const std::string_view& str,
        Cesium3DTiles::Extension3dTilesContentGltf& o) {
  using namespace std::string_literals;

  if ("extensionsUsed"s == str)
    return property("extensionsUsed", this->_extensionsUsed, o.extensionsUsed);
  if ("extensionsRequired"s == str)
    return property(
        "extensionsRequired",
        this->_extensionsRequired,
        o.extensionsRequired);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "Extension3dTilesMultipleContentsJsonHandler.h"

#include <Cesium3DTiles/Extension3dTilesMultipleContents.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

Extension3dTilesMultipleContentsJsonHandler::
    Extension3dTilesMultipleContentsJsonHandler(
        const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _content(context) {}

void Extension3dTilesMultipleContentsJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Extension3dTilesMultipleContents* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
Extension3dTilesMultipleContentsJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtension3dTilesMultipleContents(
      Cesium3DTiles::Extension3dTilesMultipleContents::TypeName,
      str,
      *this->_pObject);
}

void Extension3dTilesMultipleContentsJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumUtility::ExtensibleObject& o,
    const std::string_view& extensionName) {
  std::any& value = o.extensions
                        .emplace(
                            extensionName,
                            Cesium3DTiles::Extension3dTilesMultipleContents())
                        .first->second;
  this->reset(
      pParentHandler,
      &std::any_cast<Cesium3DTiles::Extension3dTilesMultipleContents&>(value));
}

CesiumJsonReader::IJsonHandler* Extension3dTilesMultipleContentsJsonHandler::
    readObjectKeyExtension3dTilesMultipleContents(
        const std::string& objectType,
        const std::string_view& str,
        Cesium3DTiles::Extension3dTilesMultipleContents& o) {
  using namespace std::string_literals;

  if ("content"s == str)
    return property("content", this->_content, o.content);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "Extension3dTilesBoundingVolumeS2JsonHandler.h"

#include <Cesium3DTiles/Extension3dTilesBoundingVolumeS2.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

Extension3dTilesBoundingVolumeS2JsonHandler::
    Extension3dTilesBoundingVolumeS2JsonHandler(
        const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _token(),
      _minimumHeight(),
      _maximumHeight() {}

void Extension3dTilesBoundingVolumeS2JsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Extension3dTilesBoundingVolumeS2* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
Extension3dTilesBoundingVolumeS2JsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtension3dTilesBoundingVolumeS2(
      Cesium3DTiles::Extension3dTilesBoundingVolumeS2::TypeName,
      str,
      *this->_pObject);
}

void Extension3dTilesBoundingVolumeS2JsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumUtility::ExtensibleObject& o,
    const std::string_view& extensionName) {
  std::any& value = o.extensions
                        .emplace(
                            extensionName,
                            Cesium3DTiles::Extension3dTilesBoundingVolumeS2())
                        .first->second;
  this->reset(
      pParentHandler,
      &std::any_cast<Cesium3DTiles::Extension3dTilesBoundingVolumeS2&>(value));
}

CesiumJsonReader::IJsonHandler* Extension3dTilesBoundingVolumeS2JsonHandler::
    readObjectKeyExtension3dTilesBoundingVolumeS2(
        const std::string& objectType,
        const std::string_view& str,
        Cesium3DTiles::Extension3dTilesBoundingVolumeS2& o) {
  using namespace std::string_literals;

  if ("token"s == str)
    return property("token", this->_token, o.token);
  if ("minimumHeight"s == str)
    return property("minimumHeight", this->_minimumHeight, o.minimumHeight);
  if ("maximumHeight"s == str)
    return property("maximumHeight", this->_maximumHeight, o.maximumHeight);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "Extension3dTilesImplicitTilingJsonHandler.h"

#include <Cesium3DTiles/Extension3dTilesImplicitTiling.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

Extension3dTilesImplicitTilingJsonHandler::
    Extension3dTilesImplicitTilingJsonHandler(
        const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _subdivisionScheme(),
      _subtreeLevels(),
      _maximumLevel(),
      _subtrees(context) {}

void Extension3dTilesImplicitTilingJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Extension3dTilesImplicitTiling* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
Extension3dTilesImplicitTilingJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtension3dTilesImplicitTiling(
      Cesium3DTiles::Extension3dTilesImplicitTiling::TypeName,
      str,
      *this->_pObject);
}

void Extension3dTilesImplicitTilingJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumUtility::ExtensibleObject& o,
    const std::string_view& extensionName) {
  std::any& value = o.extensions
                        .emplace(
                            extensionName,
                            Cesium3DTiles::Extension3dTilesImplicitTiling())
                        .first->second;
  this->reset(
      pParentHandler,
      &std::any_cast<Cesium3DTiles::Extension3dTilesImplicitTiling&>(value));
}

CesiumJsonReader::IJsonHandler* Extension3dTilesImplicitTilingJsonHandler::
    readObjectKeyExtension3dTilesImplicitTiling(
        const std::string& objectType,
        const std::string_view& str,
        Cesium3DTiles::Extension3dTilesImplicitTiling& o) {
  using namespace std::string_literals;

  if ("subdivisionScheme"s == str)
    return property(
        "subdivisionScheme",
        this->_subdivisionScheme,
        o.subdivisionScheme);
  if ("subtreeLevels"s == str)
    return property("subtreeLevels", this->_subtreeLevels, o.subtreeLevels);
  if ("maximumLevel"s == str)
    return property("maximumLevel", this->_maximumLevel, o.maximumLevel);
  if ("subtrees"s == str)
    return property("subtrees", this->_subtrees, o.subtrees);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "Extension3dTilesImplicitTilingExtension3dTilesMultipleContentsJsonHandler.h"

#include <Cesium3DTiles/Extension3dTilesImplicitTilingExtension3dTilesMultipleContents.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

Extension3dTilesImplicitTilingExtension3dTilesMultipleContentsJsonHandler::
    Extension3dTilesImplicitTilingExtension3dTilesMultipleContentsJsonHandler(
        const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _contentAvailability(context) {}

void Extension3dTilesImplicitTilingExtension3dTilesMultipleContentsJsonHandler::
    reset(
        CesiumJsonReader::IJsonHandler* pParentHandler,
        Cesium3DTiles::
            Extension3dTilesImplicitTilingExtension3dTilesMultipleContents*
                pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
Extension3dTilesImplicitTilingExtension3dTilesMultipleContentsJsonHandler::
    readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this
      ->readObjectKeyExtension3dTilesImplicitTilingExtension3dTilesMultipleContents(
          Cesium3DTiles::
              Extension3dTilesImplicitTilingExtension3dTilesMultipleContents::
                  TypeName,
          str,
          *this->_pObject);
}

void Extension3dTilesImplicitTilingExtension3dTilesMultipleContentsJsonHandler::
    reset(
        CesiumJsonReader::IJsonHandler* pParentHandler,
        CesiumUtility::ExtensibleObject& o,
        const std::string_view& extensionName) {
  std::any& value =
      o.extensions
          .emplace(
              extensionName,
              Cesium3DTiles::
                  Extension3dTilesImplicitTilingExtension3dTilesMultipleContents())
          .first->second;
  this->reset(
      pParentHandler,
      &std::any_cast<
          Cesium3DTiles::
              Extension3dTilesImplicitTilingExtension3dTilesMultipleContents&>(
          value));
}

CesiumJsonReader::IJsonHandler*
Extension3dTilesImplicitTilingExtension3dTilesMultipleContentsJsonHandler::
    readObjectKeyExtension3dTilesImplicitTilingExtension3dTilesMultipleContents(
        const std::string& objectType,
        const std::string_view& str,
        Cesium3DTiles::
            Extension3dTilesImplicitTilingExtension3dTilesMultipleContents& o) {
  using namespace std::string_literals;

  if ("contentAvailability"s == str)
    return property(
        "contentAvailability",
        this->_contentAvailability,
        o.contentAvailability);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "AvailabilityJsonHandler.h"

#include <Cesium3DTiles/Availability.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

AvailabilityJsonHandler::AvailabilityJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _bufferView(),
      _availableCount(),
      _constant() {}

void AvailabilityJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Availability* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
AvailabilityJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyAvailability(
      Cesium3DTiles::Availability::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
AvailabilityJsonHandler::readObjectKeyAvailability(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::Availability& o) {
  using namespace std::string_literals;

  if ("bufferView"s == str)
    return property("bufferView", this->_bufferView, o.bufferView);
  if ("availableCount"s == str)
    return property("availableCount", this->_availableCount, o.availableCount);
  if ("constant"s == str)
    return property("constant", this->_constant, o.constant);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "SubtreesJsonHandler.h"

#include <Cesium3DTiles/Subtrees.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

SubtreesJsonHandler::SubtreesJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context), _uri() {}

void SubtreesJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Subtrees* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
SubtreesJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeySubtrees(
      Cesium3DTiles::Subtrees::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* SubtreesJsonHandler::readObjectKeySubtrees(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::Subtrees& o) {
  using namespace std::string_literals;

  if ("uri"s == str)
    return property("uri", this->_uri, o.uri);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ContentJsonHandler.h"

#include <Cesium3DTiles/Content.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

ContentJsonHandler::ContentJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _boundingVolume(context),
      _uri() {}

void ContentJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Content* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ContentJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyContent(
      Cesium3DTiles::Content::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* ContentJsonHandler::readObjectKeyContent(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::Content& o) {
  using namespace std::string_literals;

  if ("boundingVolume"s == str)
    return property("boundingVolume", this->_boundingVolume, o.boundingVolume);
  if ("uri"s == str)
    return property("uri", this->_uri, o.uri);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "BoundingVolumeJsonHandler.h"

#include <Cesium3DTiles/BoundingVolume.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

BoundingVolumeJsonHandler::BoundingVolumeJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _box(),
      _region(),
      _sphere() {}

void BoundingVolumeJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::BoundingVolume* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
BoundingVolumeJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyBoundingVolume(
      Cesium3DTiles::BoundingVolume::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
BoundingVolumeJsonHandler::readObjectKeyBoundingVolume(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::BoundingVolume& o) {
  using namespace std::string_literals;

  if ("box"s == str)
    return property("box", this->_box, o.box);
  if ("region"s == str)
    return property("region", this->_region, o.region);
  if ("sphere"s == str)
    return property("sphere", this->_sphere, o.sphere);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "SubtreeJsonHandler.h"

#include <Cesium3DTiles/Subtree.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

SubtreeJsonHandler::SubtreeJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _buffers(context),
      _bufferViews(context),
      _tileAvailability(context),
      _childSubtreeAvailability(context),
      _contentAvailability(context) {}

void SubtreeJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Subtree* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
SubtreeJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeySubtree(
      Cesium3DTiles::Subtree::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* SubtreeJsonHandler::readObjectKeySubtree(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::Subtree& o) {
  using namespace std::string_literals;

  if ("buffers"s == str)
    return property("buffers", this->_buffers, o.buffers);
  if ("bufferViews"s == str)
    return property("bufferViews", this->_bufferViews, o.bufferViews);
  if ("tileAvailability"s == str)
    return property(
        "tileAvailability",
        this->_tileAvailability,
        o.tileAvailability);
  if ("childSubtreeAvailability"s == str)
    return property(
        "childSubtreeAvailability",
        this->_childSubtreeAvailability,
        o.childSubtreeAvailability);
  if ("contentAvailability"s == str)
    return property(
        "contentAvailability",
        this->_contentAvailability,
        o.contentAvailability);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "BufferViewJsonHandler.h"

#include <Cesium3DTiles/BufferView.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

BufferViewJsonHandler::BufferViewJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _buffer(),
      _byteOffset(),
      _byteLength(),
      _name() {}

void BufferViewJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::BufferView* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
BufferViewJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyBufferView(
      Cesium3DTiles::BufferView::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* BufferViewJsonHandler::readObjectKeyBufferView(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::BufferView& o) {
  using namespace std::string_literals;

  if ("buffer"s == str)
    return property("buffer", this->_buffer, o.buffer);
  if ("byteOffset"s == str)
    return property("byteOffset", this->_byteOffset, o.byteOffset);
  if ("byteLength"s == str)
    return property("byteLength", this->_byteLength, o.byteLength);
  if ("name"s == str)
    return property("name", this->_name, o.name);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "BufferJsonHandler.h"

#include <Cesium3DTiles/Buffer.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

BufferJsonHandler::BufferJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _uri(),
      _byteLength(),
      _name() {}

void BufferJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Buffer* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
BufferJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyBuffer(
      Cesium3DTiles::Buffer::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* BufferJsonHandler::readObjectKeyBuffer(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::Buffer& o) {
  using namespace std::string_literals;

  if ("uri"s == str)
    return property("uri", this->_uri, o.uri);
  if ("byteLength"s == str)
    return property("byteLength", this->_byteLength, o.byteLength);
  if ("name"s == str)
    return property("name", this->_name, o.name);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "TilesetJsonHandler.h"

#include <Cesium3DTiles/Tileset.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

TilesetJsonHandler::TilesetJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _asset(context),
      _properties(context),
      _geometricError(),
      _root(context),
      _extensionsUsed(),
      _extensionsRequired() {}

void TilesetJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Tileset* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
TilesetJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyTileset(
      Cesium3DTiles::Tileset::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* TilesetJsonHandler::readObjectKeyTileset(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::Tileset& o) {
  using namespace std::string_literals;

  if ("asset"s == str)
    return property("asset", this->_asset, o.asset);
  if ("properties"s == str)
    return property("properties", this->_properties, o.properties);
  if ("geometricError"s == str)
    return property("geometricError", this->_geometricError, o.geometricError);
  if ("root"s == str)
    return property("root", this->_root, o.root);
  if ("extensionsUsed"s == str)
    return property("extensionsUsed", this->_extensionsUsed, o.extensionsUsed);
  if ("extensionsRequired"s == str)
    return property(
        "extensionsRequired",
        this->_extensionsRequired,
        o.extensionsRequired);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "TileJsonHandler.h"

#include <Cesium3DTiles/Tile.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

TileJsonHandler::TileJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _boundingVolume(context),
      _viewerRequestVolume(context),
      _geometricError(),
      _refine(),
      _transform(),
      _content(context),
      _children(context) {}

void TileJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Tile* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
TileJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyTile(
      Cesium3DTiles::Tile::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* TileJsonHandler::readObjectKeyTile(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::Tile& o) {
  using namespace std::string_literals;

  if ("boundingVolume"s == str)
    return property("boundingVolume", this->_boundingVolume, o.boundingVolume);
  if ("viewerRequestVolume"s == str)
    return property(
        "viewerRequestVolume",
        this->_viewerRequestVolume,
        o.viewerRequestVolume);
  if ("geometricError"s == str)
    return property("geometricError", this->_geometricError, o.geometricError);
  if ("refine"s == str)
    return property("refine", this->_refine, o.refine);
  if ("transform"s == str)
    return property("transform", this->_transform, o.transform);
  if ("content"s == str)
    return property("content", this->_content, o.content);
  if ("children"s == str)
    return property("children", this->_children, o.children);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "PropertiesJsonHandler.h"

#include <Cesium3DTiles/Properties.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

PropertiesJsonHandler::PropertiesJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _maximum(),
      _minimum() {}

void PropertiesJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Properties* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
PropertiesJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyProperties(
      Cesium3DTiles::Properties::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* PropertiesJsonHandler::readObjectKeyProperties(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::Properties& o) {
  using namespace std::string_literals;

  if ("maximum"s == str)
    return property("maximum", this->_maximum, o.maximum);
  if ("minimum"s == str)
    return property("minimum", this->_minimum, o.minimum);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "AssetJsonHandler.h"

#include <Cesium3DTiles/Asset.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

AssetJsonHandler::AssetJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _version(),
      _tilesetVersion() {}

void AssetJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Asset* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
AssetJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyAsset(
      Cesium3DTiles::Asset::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* AssetJsonHandler::readObjectKeyAsset(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::Asset& o) {
  using namespace std::string_literals;

  if ("version"s == str)
    return property("version", this->_version, o.version);
  if ("tilesetVersion"s == str)
    return property("tilesetVersion", this->_tilesetVersion, o.tilesetVersion);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
