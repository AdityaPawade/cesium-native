// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#pragma once

#include "Cesium3DTiles/Library.h"

#include <CesiumUtility/ExtensibleObject.h>

#include <cstdint>
#include <optional>

namespace Cesium3DTiles {
/**
 * @brief An array of binary property values.
 */
struct CESIUM3DTILES_API SubtreeMetadataProperty final
    : public CesiumUtility::ExtensibleObject {
  static inline constexpr const char* TypeName = "SubtreeMetadataProperty";

  /**
   * @brief Known values for The type of values in `arrayOffsetBufferView`.
   */
  struct ArrayOffsetType {
    inline static const std::string UINT8 = "UINT8";

    inline static const std::string UINT16 = "UINT16";

    inline static const std::string UINT32 = "UINT32";

    inline static const std::string UINT64 = "UINT64";
  };

  /**
   * @brief Known values for The type of values in `stringOffsetBufferView`.
   */
  struct StringOffsetType {
    inline static const std::string UINT8 = "UINT8";

    inline static const std::string UINT16 = "UINT16";

    inline static const std::string UINT32 = "UINT32";

    inline static const std::string UINT64 = "UINT64";
  };

  /**
   * @brief The index of the buffer view containing property values. The data
   * type of property values is determined by the property definition: When
   * `componentType` is `BOOLEAN` values are packed into a bitstream. When
   * `componentType` is `STRING` values are stored as byte sequences and decoded
   * as UTF-8 strings. When `componentType` is a numeric type values are stored
   * as the provided `componentType`. When `componentType` is `ENUM` values are
   * stored as the enum's `valueType`. Each enum value in the buffer must match
   * one of the allowed values in the enum definition. When `type` is `ARRAY`
   * elements are packed tightly together and the data type is based on the
   * `componentType` following the same rules as above. `arrayOffsetBufferView`
   * is required for variable-size arrays and `stringOffsetBufferView` is
   * required for strings (for variable-length arrays of strings, both are
   * required). The buffer view `byteOffset` must be aligned to a multiple of
   * the `componentType` size.
   */
  int64_t bufferView = int64_t();

  /**
   * @brief The type of values in `arrayOffsetBufferView`.
   *
   * Known values are defined in {@link ArrayOffsetType}.
   *
   */
  std::string arrayOffsetType = ArrayOffsetType::UINT32;

  /**
   * @brief The index of the buffer view containing offsets for variable-length
   * arrays. The number of offsets is equal to the number of available tiles
   * plus one. The offsets represent the start positions of each array, with the
   * last offset representing the position after the last array. The array
   * length is computed using the difference between the current offset and the
   * subsequent offset. If `componentType` is `STRING` the offsets index into
   * the string offsets array (stored in `stringOffsetBufferView`), otherwise
   * they index into the property array (stored in `bufferView`). The data type
   * of these offsets is determined by `arrayOffsetType`. The buffer view
   * `byteOffset` must be aligned to a multiple of the `arrayOffsetType` size.
   */
  std::optional<int64_t> arrayOffsetBufferView;

  /**
   * @brief The type of values in `stringOffsetBufferView`.
   *
   * Known values are defined in {@link StringOffsetType}.
   *
   */
  std::string stringOffsetType = StringOffsetType::UINT32;

  /**
   * @brief The index of the buffer view containing offsets for strings. The
   * number of offsets is equal to the number of string components plus one. The
   * offsets represent the byte offsets of each string in the main `bufferView`,
   * with the last offset representing the byte offset after the last string.
   * The string byte length is computed using the difference between the current
   * offset and the subsequent offset. The data type of these offsets is
   * determined by `stringOffsetType`. The buffer view `byteOffset` must be
   * aligned to a multiple of the `stringOffsetType` size.
   */
  std::optional<int64_t> stringOffsetBufferView;
};
} // namespace Cesium3DTiles
